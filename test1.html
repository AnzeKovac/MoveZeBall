<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Move the Ball</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
        }

        body {
            background-color: #ffffff;
            margin: 0;
            overflow: hidden;
            font-family: arial;
        }
    </style>
</head>
<body>
<script src="libs/three.js"></script>
<script src="libs/cannon.js"></script>
<script src="scripts/keyboard.js"></script>

<script>
    // CONSTANTS
    var PLAYER_MASS = 50, ID_GROUND = "GROUND";

    // main
    var world, timeStep = 1 / 60, scene, renderer, camera;

    // Ground
    var groundMesh, groundBody, groundShape;

    // Player (ball)
    var playerMesh, playerBody, playerShape;

    // Other objects
    var obstacle1Bodies = [], obstacle1Meshes = [];

    // logic
    var canJump;

    ////// GAME START /////
    initCannon();
    initThree();
    animate();

    /**
     * Physics initialization of Cannon.js
     */
    function initCannon() {
        // init world
        world = new CANNON.World();
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;
        world.solver.tolerance = 0.1;
        world.gravity.set(0, -100, 0);
        world.defaultContactMaterial.contactEquationStiffness = 1e9;
        world.defaultContactMaterial.contactEquationRegularizationTime = 4;

        //// PLAYER ////
        playerShape = new CANNON.Sphere(10);
        playerBody = new CANNON.Body({
            mass: PLAYER_MASS
        });
        playerBody.addShape(playerShape);
        playerBody.position.set(0, 20, 0);
        playerBody.linearDamping = 0.5;
        world.add(playerBody);

        // collision detection for player
        playerBody.addEventListener("collide", function (e) {
            // contact.bi and contact.bj are the colliding bodies, and contact.ni is the collision normal.
            // We do not yet know which one is which! Let's check.
            var contact = e.contact;
            if (contact.bj.id == ID_GROUND) {
                canJump = true;
            }
        });
        ///////////////


        //// GROUND ////
        groundShape = new CANNON.Plane();
        groundBody = new CANNON.Body({
            mass: 0 // mass == 0 makes the body static
        });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        groundBody.position.set(0, 0, 0);
        groundBody.id = ID_GROUND;
        world.add(groundBody);
        ///////////////

        // Create a slippery material (friction coefficient = 0.0)
        var physicsMaterial = new CANNON.Material("slipperyMaterial");
        var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
                physicsMaterial,
                0.0, // friction coefficient
                0.3  // restitution
        );
        // We must add the contact materials to the world
        world.addContactMaterial(physicsContactMaterial);
        var ballContact = new CANNON.ContactMaterial(groundBody, playerBody, 0.0, 0.0);
        world.addContactMaterial(ballContact);
    }

    /**
     * Three.js initialization of the world, camera, renderer, scene and objects
     */
    function initThree() {
        //// INITIALIZE THREE.js /////
        scene = new THREE.Scene();
        renderer = new THREE.WebGLRenderer();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var light = new THREE.AmbientLight(0x404040),
                directionalLight = new THREE.DirectionalLight(0xffffff);


        scene.add(directionalLight);
        scene.add(light);
        scene.add(camera);
        scene.fog = new THREE.Fog(0x000000, 0, 500);

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(scene.fog.color, 1);
        document.body.appendChild(renderer.domElement);
        camera.position.set(0, 25, 100); // camera position to x , y , z
        camera.lookAt(new THREE.Vector3());
        directionalLight.position.set(1, 0.75, 0.5).normalize();
        ///////////////

        ///// MATERIALS and TEXTURES ////
        var playerTexture = THREE.ImageUtils.loadTexture('textures/marble.png');
        var playerMaterial = new THREE.MeshBasicMaterial({map: playerTexture});

        var groundTexture = THREE.ImageUtils.loadTexture('textures/ground_grass.jpg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(15, 15);
        var groundMaterial = new THREE.MeshBasicMaterial({map: groundTexture});

        var boxTexture = THREE.ImageUtils.loadTexture('textures/crate.png');
        var boxMaterial = new THREE.MeshBasicMaterial({map: boxTexture});
        //////////////////////////

        /////////////// OBJECTS - MAIN PART /////////////////
        /////////////////////////////////////////////////////

        // Player
        var playerGeometry = new THREE.SphereGeometry(10, 32, 32);
        playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
        playerMesh.castShadow = true;
        scene.add(playerMesh);

        // Ground
        var groundGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1);
        groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.castShadow = true;
        groundMesh.useQuaternion = true;
        groundMesh.position.set(0, 0, 0);
        groundBody.position.set(0, 0, 0);
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);


        // Obstacle 1
        var halfExtents = new CANNON.Vec3(10, 10, 10);
        var boxShape = new CANNON.Box(halfExtents);
        var boxGeometry = new THREE.BoxGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2);
        // create a row of boxes
        for (var i = 0; i < 5; i++) {
            var x = i * (halfExtents.x * 2 + 2);
            var y = 15;
            var z = -30;
            var boxBody = new CANNON.Body({mass: 30});
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            obstacle1Bodies.push(boxBody);
            obstacle1Meshes.push(boxMesh);
        }

        /////////////////////////////////////////////////////
        /////////////////////////////////////////////////////
    }

    function animate() {
        requestAnimationFrame(animate);

        handleKeyInput();

        updatePhysics();
        render();
    }

    function handleKeyInput() {
        var moveDistance = canJump ? 10 : 5;
        var maxSpeed = canJump ? 60 : 30;

        if (Key.isDown(Key.W)) {
            if (Math.abs(playerBody.velocity.z) > maxSpeed) playerBody.velocity.z += moveDistance;
            playerBody.velocity.z += -moveDistance;
        }
        if (Key.isDown(Key.S)) {
            if (Math.abs(playerBody.velocity.z) > maxSpeed) playerBody.velocity.z += -moveDistance;
            playerBody.velocity.z += moveDistance;
        }
        if (Key.isDown(Key.A)) {
            if (Math.abs(playerBody.velocity.x) > maxSpeed) playerBody.velocity.x += moveDistance;
            playerBody.velocity.x += -moveDistance;
        }
        if (Key.isDown(Key.D)) {
            if (Math.abs(playerBody.velocity.x) > maxSpeed) playerBody.velocity.x += -moveDistance;
            playerBody.velocity.x += moveDistance;
        }
        if (Key.isDown(Key.SPACE) && canJump === true) {
            playerBody.velocity.y = 100;
            canJump = false;
        }
    }

    function updatePhysics() {
        // Step the physics world
        world.step(timeStep);

        // Copy coordinates from Cannon.js to Three.js
        playerMesh.position.copy(playerBody.position);
        playerMesh.quaternion.copy(playerBody.quaternion);

        groundMesh.position.copy(groundBody.position);
        groundMesh.quaternion.copy(groundBody.quaternion);

        // Update box positions
        for (var i = 0; i < obstacle1Bodies.length; i++) {
            obstacle1Meshes[i].position.copy(obstacle1Bodies[i].position);
            obstacle1Meshes[i].quaternion.copy(obstacle1Bodies[i].quaternion);
        }

        camera.lookAt(playerMesh.position);
        camera.position.x = playerMesh.position.x;
        camera.position.y = playerMesh.position.y + 15;
        camera.position.z = playerMesh.position.z + 50;
    }
    function render() {
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
