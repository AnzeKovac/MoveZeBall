<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Move the Ball</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
        }

        body {
            background-color: #ffffff;
            margin: 0;
            overflow: hidden;
            font-family: arial;
        }
    </style>
</head>
<body>
<script src="libs/three.js"></script>
<script src="libs/cannon.js"></script>
<script src="scripts/keyboard.js"></script>

<script>
    var world, timeStep = 1 / 60, scene, renderer, camera,
            icosahedronBody, sphereShape, groundShape,
            ground, groundBody, groundShape;
    // CONSTANTS
    var GRID_HELPER_SIZE = 40,
            GRID_HELPER_STEP = 2,
            MASS = 5;

    var canJump;

    initThree();
    initCannon();
    animate();

    function initCannon() {
        world = new CANNON.World();
        world.broadphase = new CANNON.NaiveBroadphase();
        sphereShape = new CANNON.Sphere(10);
        groundShape = new CANNON.Plane();

        var sphereBody = new CANNON.Body({
           mass: 10,// kg
           position: new CANNON.Vec3(0, 10, 10), // m
           shape: new CANNON.Sphere(5)
        });
        world.addBody(sphereBody);

        icosahedronBody = new CANNON.Body({
            mass: MASS,
        });
        groundBody = new CANNON.Body({
            mass: 0, // mass == 0 makes the body static
        });

        world.solver.iterations = 10;
        world.gravity.set(0, -100, 0);
        world.defaultContactMaterial.contactEquationStiffness = 1e9;
        world.defaultContactMaterial.contactEquationRegularizationTime = 4;

        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        groundBody.position.set(0, 0, 0);
        groundBody.id = "GROUND";
        world.addBody(groundBody);

        icosahedronBody.addShape(sphereShape);
        icosahedronBody.position.set(0, 15, 0);
        icosahedronBody.linearDamping = 0.5;
        world.addBody(icosahedronBody);

        icosahedronBody.addEventListener("collide", function (e) {
            // contact.bi and contact.bj are the colliding bodies, and contact.ni is the collision normal.
            // We do not yet know which one is which! Let's check.
            var contact = e.contact;
            if(contact.bj.id == "GROUND"){
                canJump = true;
            }
        });

        var ballContact = new CANNON.ContactMaterial(groundBody, icosahedronBody, 0.0, 0.0);

        world.addContactMaterial(ballContact);
    }

    function initThree() {
        // INITIALIZE CANVAS
        scene = new THREE.Scene();
        renderer = new THREE.WebGLRenderer();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var light = new THREE.AmbientLight(0x404040),
                directionalLight = new THREE.DirectionalLight(0xffffff),
                gridHelper = new THREE.GridHelper(GRID_HELPER_SIZE, GRID_HELPER_STEP);


        scene.add(directionalLight);
        scene.add(light);
        scene.add(camera);
        scene.add(gridHelper);
        scene.fog = new THREE.Fog(0x000000, 0, 500);

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(scene.fog.color, 1);
        document.body.appendChild(renderer.domElement);
        camera.position.set(0, 25, 100); // camera position to x , y , z
        camera.lookAt(new THREE.Vector3());
        directionalLight.position.set(1, 0.75, 0.5).normalize();


        // MATERIALS
        var moonTexture = THREE.ImageUtils.loadTexture( 'textures/marble.png' );
        var moonMaterial = new THREE.MeshBasicMaterial( { map: moonTexture } );
        var icoGeometry = new THREE.SphereGeometry(10, 32, 32),

        icoMaterial = new THREE.MeshLambertMaterial({color: 0xdddddd});
        icosahedron = new THREE.Mesh(icoGeometry, moonMaterial);
//        icosahedron.add(camera);



        var groundGeometry = new THREE.BoxGeometry(100, 100, 1),
        groundMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc});
        ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.receiveShadow = true;

        var ballGeometry = new THREE.BoxGeometry(100, 100, 1),
        ballMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc});
        ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.receiveShadow = true;

        // ADD OBJECTS TO SCENE

        scene.add(ground);
        scene.add(icosahedron);
        scene.add(ball);
    }

    function animate() {
        requestAnimationFrame(animate);

        handleKeyInput();

        updatePhysics();
        render();
    }

    function handleKeyInput() {
        var moveDistance = canJump ? 10 : 5;
        var maxSpeed = canJump ? 60 : 30;

        if(Key.isDown(Key.W) ){
            if(Math.abs(icosahedronBody.velocity.z) > maxSpeed ) icosahedronBody.velocity.z +=moveDistance;
            icosahedronBody.velocity.z +=-moveDistance;
        }
        if(Key.isDown(Key.S) ){
            if(Math.abs(icosahedronBody.velocity.z) > maxSpeed ) icosahedronBody.velocity.z +=-moveDistance;
            icosahedronBody.velocity.z +=moveDistance;
        }
        if(Key.isDown(Key.A) ){
            if(Math.abs(icosahedronBody.velocity.x) > maxSpeed ) icosahedronBody.velocity.x +=moveDistance;
            icosahedronBody.velocity.x +=-moveDistance;
        }
        if(Key.isDown(Key.D) ){
            if(Math.abs(icosahedronBody.velocity.x) > maxSpeed ) icosahedronBody.velocity.x +=-moveDistance;
            icosahedronBody.velocity.x +=moveDistance;
        }
        if(Key.isDown(Key.SPACE) && canJump === true){
            icosahedronBody.velocity.y = 100 ;
            canJump = false;
        }
    }

    function updatePhysics() {
        // Step the physics world
        world.step(timeStep);
        // Copy coordinates from Cannon.js to Three.js
        icosahedronBody.velocity.x += 0.1;

        icosahedron.position.copy(icosahedronBody.position);
        icosahedron.quaternion.copy(icosahedronBody.quaternion);

        ground.position.copy(groundBody.position);
        ground.quaternion.copy(groundBody.quaternion);


        camera.lookAt(icosahedron.position);
        camera.position.x = icosahedron.position.x;
        camera.position.y = icosahedron.position.y + 15;
        camera.position.z = icosahedron.position.z + 50;
    }
    function render() {
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
